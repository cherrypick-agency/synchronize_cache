# Offline-First Flutter: A Practical Guide to Data Synchronization

How do you build an app that works offline as smoothly as online? In this article, we'll walk through a real TODO app with offline-first architecture in Flutter.

---

## What is Offline-First?

The principle is simple:
1. **Read locally** — data always comes from the local database
2. **Write locally** — changes are saved locally first
3. **Sync when possible** — when online, push changes to server and pull updates

Users never see a loading spinner when opening the task list. Everything works instantly.

---

## Two Examples: Simple vs Advanced

The [synchronize_cache](https://github.com/cherrypick-agency/synchronize_cache) repository contains two TODO app examples:

| Aspect | **Simple** | **Advanced** |
|--------|-----------|--------------|
| Conflict resolution | Automatic (autoPreserve) | Manual (user dialogs) |
| Conflict UI | None | ConflictDialog included |
| Logging | Minimal | Detailed with log screen |
| Server simulation | None | Test endpoints included |
| Code complexity | Minimal | Medium |

**This article** covers the **Simple** version — it demonstrates a minimal but fully working offline-first approach.

**The next article** will cover **Advanced** — where we'll show how to give users control over conflicts.

---

## Project Structure

```
todo_simple/
├── backend/           # Dart Frog server
│   ├── routes/
│   │   └── todos/     # REST API endpoints
│   └── lib/
│       ├── models/
│       └── repositories/
└── frontend/          # Flutter app
    └── lib/
        ├── database/  # Drift database
        ├── models/
        ├── repositories/
        ├── services/  # SyncService
        └── ui/
```

[Full code on GitHub](https://github.com/cherrypick-agency/synchronize_cache/tree/main/example/todo_simple)

---

## Step 1: Dependencies

```yaml
dependencies:
  flutter:
    sdk: flutter
  drift: ^2.27.0
  drift_flutter: ^0.2.4
  sqlite3_flutter_libs: ^0.5.41
  offline_first_sync_drift:
    path: ../../../packages/offline_first_sync_drift
  offline_first_sync_drift_rest:
    path: ../../../packages/offline_first_sync_drift_rest
  json_annotation: ^4.9.0
  uuid: ^4.5.2
  provider: ^6.1.5+1
  http: ^1.2.0

dev_dependencies:
  drift_dev: ^2.27.0
  build_runner: ^2.4.15
  json_serializable: ^6.9.4
```

[pubspec.yaml#L9-L32](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/pubspec.yaml#L9-L32)

---

## Step 2: Data Model

The `Todo` model contains business fields and required system fields for synchronization:

```dart
@JsonSerializable(fieldRename: FieldRename.snake)
class Todo {
  Todo({
    required this.id,
    required this.title,
    this.description,
    this.completed = false,
    this.priority = 3,
    this.dueDate,
    required this.updatedAt,
    this.deletedAt,
    this.deletedAtLocal,
  });

  /// Unique identifier (UUID), generated by the client.
  final String id;

  /// Todo title (required).
  final String title;

  /// Optional description.
  final String? description;

  /// Whether the todo is completed.
  final bool completed;

  /// Priority level (1-5, where 1 is highest).
  final int priority;

  /// Optional due date.
  final DateTime? dueDate;

  /// Last update timestamp (set by server).
  final DateTime updatedAt;

  /// Soft delete timestamp from server.
  final DateTime? deletedAt;

  /// Local delete timestamp (before sync).
  final DateTime? deletedAtLocal;

  factory Todo.fromJson(Map<String, dynamic> json) => _$TodoFromJson(json);

  Map<String, dynamic> toJson() => _$TodoToJson(this);

  // copyWith method for immutable updates...
}
```

[models/todo.dart#L8-L51](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/models/todo.dart#L8-L51)

### Why System Fields?

- **`updatedAt`** — set by the server. Used for conflict detection and pagination
- **`deletedAt`** — soft delete from server. Records aren't physically deleted, just marked
- **`deletedAtLocal`** — local soft delete. Needed until changes are synced to server

---

## Step 3: Drift Table

The Drift table uses the `SyncColumns` mixin, which automatically adds all required synchronization fields:

```dart
/// Drift table definition for todos.
///
/// Uses [SyncColumns] mixin to add synchronization fields:
/// - updatedAt
/// - deletedAt
/// - deletedAtLocal
@UseRowClass(Todo, generateInsertable: true)
class Todos extends Table with SyncColumns {
  /// Unique identifier (UUID), generated by the client.
  TextColumn get id => text()();

  /// Todo title (required).
  TextColumn get title => text().withLength(min: 1, max: 255)();

  /// Optional description.
  TextColumn get description => text().nullable()();

  /// Whether the todo is completed.
  BoolColumn get completed => boolean().withDefault(const Constant(false))();

  /// Priority level (1-5, where 1 is highest).
  IntColumn get priority => integer().withDefault(const Constant(3))();

  /// Optional due date.
  DateTimeColumn get dueDate => dateTime().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}
```

[database/tables/todos.dart#L6-L34](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/database/tables/todos.dart#L6-L34)

The `SyncColumns` mixin adds:
- `updatedAt`
- `deletedAt`
- `deletedAtLocal`

---

## Step 4: Database

The database includes sync tables from the library via `include`:

```dart
/// Application database with offline-first sync support.
///
/// Uses [SyncDatabaseMixin] to provide synchronization capabilities:
/// - Outbox for pending operations
/// - Cursors for tracking sync progress
@DriftDatabase(
  include: {'package:offline_first_sync_drift/src/sync_tables.drift'},
  tables: [Todos],
)
class AppDatabase extends _$AppDatabase with SyncDatabaseMixin {
  AppDatabase([QueryExecutor? executor])
      : super(executor ?? _openConnection());

  /// Opens a persistent database for Flutter.
  static QueryExecutor _openConnection() {
    return driftDatabase(name: 'todo_simple');
  }

  /// Opens a persistent database with custom name.
  static AppDatabase open({String name = 'todo_simple'}) {
    return AppDatabase(driftDatabase(name: name));
  }

  @override
  int get schemaVersion => 1;

  @override
  MigrationStrategy get migration => MigrationStrategy(
        onCreate: (m) async {
          await m.createAll();
        },
      );
}
```

[database/database.dart#L12-L44](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/database/database.dart#L12-L44)

### What Does SyncDatabaseMixin Provide?

- **`enqueue()`** — add operation to outbox
- **`takeOutbox()`** — get operations for sending
- **`setCursor()`** — save pagination cursor
- Tables `sync_outbox` and `sync_cursors` are added automatically via `include`

---

## Step 5: Repository

The repository is the key component. This is where the "local change + enqueue to outbox" pattern is implemented:

```dart
/// Repository for managing todos with offline-first sync support.
///
/// All CRUD operations:
/// 1. Update local database immediately
/// 2. Enqueue operation for sync to server
class TodoRepository {
  TodoRepository(this._db);

  final AppDatabase _db;
  final _uuid = const Uuid();

  /// Watches all non-deleted todos, ordered by priority and title.
  Stream<List<Todo>> watchAll() {
    return (_db.select(_db.todos)
          ..where((t) => t.deletedAt.isNull() & t.deletedAtLocal.isNull())
          ..orderBy([
            (t) => OrderingTerm(expression: t.priority),
            (t) => OrderingTerm(expression: t.title),
          ]))
        .watch();
  }

  /// Creates a new todo.
  ///
  /// Generates a UUID for the id and enqueues for sync.
  Future<Todo> create({
    required String title,
    String? description,
    bool completed = false,
    int priority = 3,
    DateTime? dueDate,
  }) async {
    final now = DateTime.now().toUtc();
    final id = _uuid.v4();

    // Validate priority range (1-5)
    final validPriority = priority.clamp(1, 5);

    final todo = Todo(
      id: id,
      title: title,
      description: description,
      completed: completed,
      priority: validPriority,
      dueDate: dueDate,
      updatedAt: now,
    );

    // Insert into local database
    await _db.into(_db.todos).insert(todo.toInsertable());

    // Enqueue for sync
    await _db.enqueue(UpsertOp(
      opId: _uuid.v4(),
      kind: 'todos',
      id: id,
      localTimestamp: now,
      payloadJson: todo.toJson(),
    ));

    return todo;
  }
```

[repositories/todo_repository.dart#L8-L86](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/repositories/todo_repository.dart#L8-L86)

### Update with Field Tracking

```dart
  /// Updates an existing todo.
  ///
  /// Tracks changed fields for efficient merge on conflict.
  Future<Todo> update(
    Todo todo, {
    String? title,
    String? description,
    bool? completed,
    int? priority,
    DateTime? dueDate,
  }) async {
    final now = DateTime.now().toUtc();
    final changedFields = <String>{};

    // Track which fields changed
    if (title != null && title != todo.title) changedFields.add('title');
    if (description != todo.description) changedFields.add('description');
    if (completed != null && completed != todo.completed) {
      changedFields.add('completed');
    }
    // Validate priority range (1-5)
    final validPriority = priority?.clamp(1, 5);
    if (validPriority != null && validPriority != todo.priority) {
      changedFields.add('priority');
    }
    if (dueDate != todo.dueDate) changedFields.add('dueDate');

    final updated = todo.copyWith(
      title: title ?? todo.title,
      description: description,
      completed: completed ?? todo.completed,
      priority: validPriority ?? todo.priority,
      dueDate: dueDate,
      updatedAt: now,
    );

    // Update local database
    await _db.update(_db.todos).replace(updated.toInsertable());

    // Enqueue for sync with changed fields
    await _db.enqueue(UpsertOp(
      opId: _uuid.v4(),
      kind: 'todos',
      id: todo.id,
      localTimestamp: now,
      payloadJson: updated.toJson(),
      baseUpdatedAt: todo.updatedAt, // For conflict detection
      changedFields: changedFields.isNotEmpty ? changedFields : null,
    ));

    return updated;
  }
```

[repositories/todo_repository.dart#L88-L139](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/repositories/todo_repository.dart#L88-L139)

### Why `changedFields`?

During a conflict, the library knows which specific fields the user modified. This enables smart merging:
- User changed `title`
- Server changed `priority`
- Result: both changes are preserved, no conflict

### Delete (Soft Delete)

```dart
  /// Deletes a todo (soft delete locally, enqueue for sync).
  Future<void> delete(Todo todo) async {
    final now = DateTime.now().toUtc();

    // Soft delete locally
    final deleted = todo.copyWith(deletedAtLocal: now);
    await _db.update(_db.todos).replace(deleted.toInsertable());

    // Enqueue delete operation
    await _db.enqueue(DeleteOp(
      opId: _uuid.v4(),
      kind: 'todos',
      id: todo.id,
      localTimestamp: now,
      baseUpdatedAt: todo.updatedAt,
    ));
  }
```

[repositories/todo_repository.dart#L146-L162](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/repositories/todo_repository.dart#L146-L162)

---

## Step 6: SyncService

SyncService ties everything together — database, transport, and sync engine:

```dart
/// Service for synchronizing todos with the server.
///
/// Uses [SyncEngine] with [RestTransport] for HTTP communication.
class SyncService extends ChangeNotifier {
  SyncService({
    required AppDatabase db,
    required String baseUrl,
    http.Client? httpClient,
    int maxRetries = 5,
    int maxPushRetries = 5,
  }) : _db = db {
    _transport = RestTransport(
      base: Uri.parse(baseUrl),
      // No auth for demo
      token: () async => '',
      client: httpClient,
      maxRetries: maxRetries,
    );

    _engine = SyncEngine(
      db: db,
      transport: _transport,
      tables: [
        SyncableTable<Todo>(
          kind: 'todos',
          table: db.todos,
          fromJson: Todo.fromJson,
          toJson: (t) => t.toJson(),
          toInsertable: (t) => t.toInsertable(),
        ),
      ],
      config: SyncConfig(
        // Use autoPreserve for simple flow - merges without conflicts
        conflictStrategy: ConflictStrategy.autoPreserve,
        pageSize: 500,
        maxPushRetries: maxPushRetries,
      ),
    );

    // Listen to sync events
    _subscription = _engine.events.listen(_handleEvent);
  }
```

[services/sync_service.dart#L34-L75](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/services/sync_service.dart#L34-L75)

### The `autoPreserve` Strategy

This is the default strategy that smartly merges data:

```
Local:   {title: "Buy milk", priority: 3}
Server:  {title: "Buy groceries", priority: 1, description: "Weekly shopping"}

Result:  {title: "Buy milk", priority: 3, description: "Weekly shopping"}
```

How it works:
1. Takes server data as base
2. Applies local changes (only `changedFields`)
3. Merges lists without duplicates
4. Recursively merges nested objects
5. Sends result with `X-Force-Update: true`

### Running Synchronization

```dart
  /// Performs a full sync (push + pull).
  Future<SyncStats> sync() async {
    _status = SyncStatus.syncing;
    _error = null;
    _progress = 0.0;
    notifyListeners();

    try {
      final stats = await _engine.sync();
      _lastStats = stats;
      _status = SyncStatus.idle;
      notifyListeners();
      return stats;
    } catch (e) {
      _error = _sanitizeError(e);
      _status = SyncStatus.error;
      notifyListeners();
      rethrow;
    }
  }
```

[services/sync_service.dart#L104-L123](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/services/sync_service.dart#L104-L123)

---

## Step 7: UI

### Sync Status Indicator

```dart
/// Widget showing current sync status with sync button.
class SyncStatusIndicator extends StatelessWidget {
  const SyncStatusIndicator({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<SyncService>(
      builder: (context, syncService, _) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Status indicator
            _StatusBadge(status: syncService.status),

            const SizedBox(width: 8),

            // Sync button
            if (syncService.isSyncing)
              const SizedBox(
                width: 24,
                height: 24,
                child: CircularProgressIndicator(strokeWidth: 2),
              )
            else
              IconButton(
                icon: const Icon(Icons.sync),
                onPressed: () => _sync(context, syncService),
                tooltip: 'Sync now',
              ),
          ],
        );
      },
    );
  }

  Future<void> _sync(BuildContext context, SyncService syncService) async {
    try {
      final stats = await syncService.sync();

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Synced: ${stats.pushed} pushed, ${stats.pulled} pulled',
            ),
            duration: const Duration(seconds: 2),
          ),
        );
      }
    } catch (_) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Sync failed. Please try again.'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}
```

[ui/widgets/sync_status_indicator.dart#L6-L66](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/ui/widgets/sync_status_indicator.dart#L6-L66)

### Main List Screen

```dart
/// Main screen showing list of todos.
class TodoListScreen extends StatelessWidget {
  const TodoListScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final repo = context.read<TodoRepository>();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Todo Simple'),
        actions: const [
          SyncStatusIndicator(),
          SizedBox(width: 8),
        ],
      ),
      body: StreamBuilder<List<Todo>>(
        stream: repo.watchAll(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 48,
                    color: Theme.of(context).colorScheme.error,
                  ),
                  const SizedBox(height: 16),
                  const Text('Failed to load todos. Please restart the app.'),
                ],
              ),
            );
          }

          final todos = snapshot.data ?? [];

          if (todos.isEmpty) {
            return const _EmptyState();
          }

          return ListView.builder(
            padding: const EdgeInsets.symmetric(vertical: 8),
            itemCount: todos.length,
            itemBuilder: (context, index) {
              final todo = todos[index];
              return TodoCard(
                key: ValueKey(todo.id),
                todo: todo,
                onToggle: () => _toggleTodo(context, repo, todo),
                onTap: () => _editTodo(context, todo),
                onDelete: () => _deleteTodo(context, repo, todo),
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _createTodo(context),
        icon: const Icon(Icons.add),
        label: const Text('Add Todo'),
      ),
    );
  }
}
```

[ui/screens/todo_list_screen.dart#L10-L78](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/ui/screens/todo_list_screen.dart#L10-L78)

Note: The UI uses `StreamBuilder` with `repo.watchAll()`. This is reactive — any change in the database (local or from sync) automatically updates the UI.

---

## Step 8: App Initialization

```dart
/// Backend server URL.
///
/// Change this to your actual backend URL.
/// Default: localhost:8080 for dart_frog dev server.
///
/// For production, configure via --dart-define:
/// flutter run --dart-define=BACKEND_URL=https://api.example.com
const kBackendUrl = String.fromEnvironment(
  'BACKEND_URL',
  defaultValue: 'http://localhost:8080',
);

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Open database
  final db = AppDatabase.open();

  // Create services
  final todoRepo = TodoRepository(db);
  final syncService = SyncService(db: db, baseUrl: kBackendUrl);

  runApp(
    MultiProvider(
      providers: [
        Provider<AppDatabase>.value(value: db),
        Provider<TodoRepository>.value(value: todoRepo),
        ChangeNotifierProvider<SyncService>.value(value: syncService),
      ],
      child: const TodoSimpleApp(),
    ),
  );
}
```

[main.dart#L9-L41](https://github.com/cherrypick-agency/synchronize_cache/blob/main/example/todo_simple/frontend/lib/main.dart#L9-L41)

---

## Running the Example

```bash
# Clone the repository
git clone https://github.com/cherrypick-agency/synchronize_cache.git
cd synchronize_cache/example/todo_simple

# Start the backend
cd backend
dart pub get
dart_frog dev

# In another terminal — frontend
cd ../frontend
flutter pub get
dart run build_runner build
flutter run
```

---

## What's Next?

In the **Advanced** version, we'll add:
- Manual conflict resolution with UI dialogs
- Diff viewer between versions
- Sync log screen
- Server simulation for testing

---

## Summary

A minimal offline-first Flutter app consists of:

1. **Model** with system fields (`updatedAt`, `deletedAt`, `deletedAtLocal`)
2. **Drift table** with `SyncColumns` mixin
3. **Database** with `SyncDatabaseMixin`
4. **Repository** — local change + `enqueue()`
5. **SyncService** with `SyncEngine` and `RestTransport`
6. **UI** using `StreamBuilder` for reactivity

All of this works out of the box with automatic conflict resolution via `autoPreserve`.

---

**Repository:** [github.com/cherrypick-agency/synchronize_cache](https://github.com/cherrypick-agency/synchronize_cache)

**todo_simple example:** [example/todo_simple](https://github.com/cherrypick-agency/synchronize_cache/tree/main/example/todo_simple)
