---
sidebar_position: 9
---
# Events and exceptions: complete reference

Complete reference of all event types (`SyncEvent`) and exceptions (`SyncException`)
generated by the `offline_first_sync_drift` sync engine.

---

## SyncEvent — base sealed class

```dart
sealed class SyncEvent {}
```

All sync events implement `SyncEvent`. It is a `sealed class`, which enables
exhaustive pattern matching in `switch`.

### Full list of subtypes

| Class                    | Purpose                                    |
|--------------------------|--------------------------------------------|
| `FullResyncStarted`     | Full resync started                        |
| `SyncStarted`           | Phase started (push or pull)               |
| `SyncProgress`          | Current phase progress                     |
| `SyncCompleted`         | Sync completed                             |
| `SyncErrorEvent`        | Sync error                                 |
| `ConflictDetectedEvent` | Data conflict detected                     |
| `ConflictResolvedEvent` | Conflict resolved                          |
| `ConflictUnresolvedEvent`| Conflict could not be resolved            |
| `DataMergedEvent`       | Data merged during merge                   |
| `CacheUpdateEvent`      | Local cache updated                        |
| `OperationPushedEvent`  | Operation successfully pushed to server    |
| `OperationFailedEvent`  | Operation failed                           |

---

## Detailed description of each event

### FullResyncStarted

Emitted when a full resync begins — when cursors are reset
and data is re-fetched from the server.

```dart
class FullResyncStarted implements SyncEvent {
  FullResyncStarted(this.reason);
  final FullResyncReason reason;
}
```

**Fields:**

| Field    | Type               | Description                            |
|----------|--------------------|----------------------------------------|
| `reason` | `FullResyncReason` | Reason for triggering the full resync  |

**When emitted:**
- On `engine.fullResync()` call — reason = `FullResyncReason.manual`
- When `fullResyncInterval` has elapsed during a regular `engine.sync()` — reason = `FullResyncReason.scheduled`

---

### SyncStarted

Emitted at the beginning of each sync phase.

```dart
class SyncStarted implements SyncEvent {
  SyncStarted(this.phase);
  final SyncPhase phase;
}
```

**Fields:**

| Field   | Type        | Description                  |
|---------|-------------|------------------------------|
| `phase` | `SyncPhase` | Phase: `push` or `pull`      |

**When emitted:**
- Before pushing local changes: `SyncStarted(SyncPhase.push)`
- Before pulling server changes: `SyncStarted(SyncPhase.pull)`

---

### SyncProgress

Current sync phase progress.

```dart
class SyncProgress implements SyncEvent {
  SyncProgress(this.phase, this.done, this.total);
  final SyncPhase phase;
  final int done;
  final int total;

  double get progress => total > 0 ? done / total : 0;
}
```

**Fields:**

| Field   | Type        | Description                                     |
|---------|-------------|-------------------------------------------------|
| `phase` | `SyncPhase` | Current phase                                   |
| `done`  | `int`       | Number of processed records                     |
| `total` | `int`       | Total number of records (at the time of event)  |

**Computed properties:**

| Property   | Type     | Description                                              |
|------------|----------|----------------------------------------------------------|
| `progress` | `double` | Progress from 0.0 to 1.0; returns 0.0 if `total == 0`   |

**When emitted:**
- After each processed data page during pull.

---

### SyncCompleted

Emitted when sync completes successfully.

```dart
class SyncCompleted implements SyncEvent {
  SyncCompleted(this.took, this.at, {this.stats});
  final Duration took;
  final DateTime at;
  final SyncStats? stats;
}
```

**Fields:**

| Field   | Type         | Description                              |
|---------|--------------|------------------------------------------|
| `took`  | `Duration`   | Sync duration                            |
| `at`    | `DateTime`   | Completion time                          |
| `stats` | `SyncStats?` | Sync statistics (may be null)            |

**When emitted:**
- After successful completion of `sync()` or `fullResync()`, one event per entire cycle.

---

### SyncErrorEvent

Emitted when an error occurs during sync.

```dart
class SyncErrorEvent implements SyncEvent {
  SyncErrorEvent(this.phase, this.error, [this.stackTrace]);
  final SyncPhase phase;
  final Object error;
  final StackTrace? stackTrace;
}
```

**Fields:**

| Field        | Type          | Description                                |
|--------------|---------------|--------------------------------------------|
| `phase`      | `SyncPhase`   | Phase where the error occurred             |
| `error`      | `Object`      | Error object (typically `SyncException`)   |
| `stackTrace` | `StackTrace?` | Stack trace                                |

**When emitted:**
- On any unhandled exception in `_doSync()` or `_doFullResync()`.
- Emitted **before** the exception is rethrown to the caller.

---

### ConflictDetectedEvent

Emitted when a data conflict is detected during push.

```dart
class ConflictDetectedEvent implements SyncEvent {
  ConflictDetectedEvent({required this.conflict, required this.strategy});
  final Conflict conflict;
  final ConflictStrategy strategy;
}
```

**Fields:**

| Field      | Type               | Description                              |
|------------|--------------------|------------------------------------------|
| `conflict` | `Conflict`         | Full conflict information                |
| `strategy` | `ConflictStrategy` | Strategy that will be applied            |

**When emitted:**
- When a `PushConflict` is received from the server, before conflict resolution begins.

---

### ConflictResolvedEvent

Emitted after a conflict is successfully resolved.

```dart
class ConflictResolvedEvent implements SyncEvent {
  ConflictResolvedEvent({
    required this.conflict,
    required this.resolution,
    this.resultData,
  });
  final Conflict conflict;
  final ConflictResolution resolution;
  final Map<String, Object?>? resultData;
}
```

**Fields:**

| Field        | Type                     | Description                                |
|--------------|--------------------------|--------------------------------------------|
| `conflict`   | `Conflict`               | Conflict information                       |
| `resolution` | `ConflictResolution`     | Resolution method (AcceptServer, AcceptClient, AcceptMerged, DiscardOperation) |
| `resultData` | `Map<String, Object?>?`  | Resulting data after resolution            |

**When emitted:**
- After any conflict resolution strategy is successfully applied.

---

### ConflictUnresolvedEvent

Emitted when a conflict could not be resolved automatically.

```dart
class ConflictUnresolvedEvent implements SyncEvent {
  ConflictUnresolvedEvent({required this.conflict, required this.reason});
  final Conflict conflict;
  final String reason;
}
```

**Fields:**

| Field      | Type       | Description                                |
|------------|------------|--------------------------------------------|
| `conflict` | `Conflict` | Conflict information                       |
| `reason`   | `String`   | Reason why the conflict could not be resolved |

**When emitted:**
- With `manual` strategy, if `conflictResolver` is not set: `"No conflict resolver provided for manual strategy"`
- When `DeferResolution` is chosen: `"Resolution deferred"`

---

### DataMergedEvent

Emitted with the `autoPreserve` strategy when data was merged.

```dart
class DataMergedEvent implements SyncEvent {
  DataMergedEvent({
    required this.kind,
    required this.entityId,
    required this.localFields,
    required this.serverFields,
    required this.mergedData,
  });
  final String kind;
  final String entityId;
  final Set<String> localFields;
  final Set<String> serverFields;
  final Map<String, Object?> mergedData;
}
```

**Fields:**

| Field          | Type                    | Description                          |
|----------------|-------------------------|--------------------------------------|
| `kind`         | `String`                | Entity type                          |
| `entityId`     | `String`                | Entity ID                            |
| `localFields`  | `Set<String>`           | Fields taken from local data         |
| `serverFields` | `Set<String>`           | Fields taken from server             |
| `mergedData`   | `Map<String, Object?>`  | Final merged data                    |

**When emitted:**
- Only with `ConflictStrategy.autoPreserve`, after `preservingMerge` is performed.

---

### CacheUpdateEvent

Emitted when the local cache is updated with server data.

```dart
class CacheUpdateEvent implements SyncEvent {
  CacheUpdateEvent(this.kind, {this.upserts = 0, this.deletes = 0});
  final String kind;
  final int upserts;
  final int deletes;
}
```

**Fields:**

| Field     | Type     | Description                                   |
|-----------|----------|-----------------------------------------------|
| `kind`    | `String` | Entity type                                   |
| `upserts` | `int`    | Number of inserted/updated records            |
| `deletes` | `int`    | Number of records with `deletedAt` (soft delete) |

**When emitted:**
- After each processed data page during pull, for each `kind`.

---

### OperationPushedEvent

Emitted when an operation is successfully pushed to the server.

```dart
class OperationPushedEvent implements SyncEvent {
  OperationPushedEvent({
    required this.opId,
    required this.kind,
    required this.entityId,
    required this.operationType,
  });
  final String opId;
  final String kind;
  final String entityId;
  final String operationType;
}
```

**Fields:**

| Field           | Type     | Description                                |
|-----------------|----------|--------------------------------------------|
| `opId`          | `String` | Operation ID from the outbox               |
| `kind`          | `String` | Entity type                                |
| `entityId`      | `String` | Entity ID                                  |
| `operationType` | `String` | Operation type (`"upsert"` or `"delete"`)  |

**When emitted:**
- When a `PushSuccess` is received from the server for each operation.

---

### OperationFailedEvent

Emitted when a push operation fails (not a conflict, but an error).

```dart
class OperationFailedEvent implements SyncEvent {
  OperationFailedEvent({
    required this.opId,
    required this.kind,
    required this.entityId,
    required this.error,
    this.willRetry = false,
  });
  final String opId;
  final String kind;
  final String entityId;
  final Object error;
  final bool willRetry;
}
```

**Fields:**

| Field      | Type     | Description                                            |
|------------|----------|--------------------------------------------------------|
| `opId`     | `String` | Operation ID                                           |
| `kind`     | `String` | Entity type                                            |
| `entityId` | `String` | Entity ID                                              |
| `error`    | `Object` | Error object                                           |
| `willRetry`| `bool`   | Whether a retry will be attempted (depends on `skipConflictingOps`) |

**When emitted:**
- When a `PushError` is received from the server for an operation.

---

## SyncPhase enum

Sync phase, used in `SyncStarted`, `SyncProgress`, `SyncErrorEvent` events.

```dart
enum SyncPhase { push, pull }
```

| Value  | Description                                    |
|--------|------------------------------------------------|
| `push` | Pushing local changes to the server            |
| `pull` | Pulling server changes into the local database |

---

## FullResyncReason enum

Reason for triggering a full resync.

```dart
enum FullResyncReason { scheduled, manual }
```

| Value       | Description                                            |
|-------------|--------------------------------------------------------|
| `scheduled` | Triggered on schedule (`fullResyncInterval` elapsed)   |
| `manual`    | Triggered manually via `engine.fullResync()`           |

---

## SyncStats

Statistics for a single sync cycle. Passed in `SyncCompleted.stats`.

```dart
class SyncStats {
  const SyncStats({
    this.pushed = 0,
    this.pulled = 0,
    this.conflicts = 0,
    this.conflictsResolved = 0,
    this.errors = 0,
  });

  final int pushed;
  final int pulled;
  final int conflicts;
  final int conflictsResolved;
  final int errors;

  SyncStats copyWith({ ... });
}
```

**Fields:**

| Field               | Type  | Description                                |
|---------------------|-------|--------------------------------------------|
| `pushed`            | `int` | Number of successfully pushed operations   |
| `pulled`            | `int` | Number of records pulled from the server   |
| `conflicts`         | `int` | Number of detected conflicts               |
| `conflictsResolved` | `int` | Number of resolved conflicts               |
| `errors`            | `int` | Number of push errors                      |

### Interpreting statistics

```dart
final stats = await engine.sync();

// All conflicts resolved
assert(stats.conflicts == stats.conflictsResolved);

// There are unresolved conflicts
if (stats.conflicts > stats.conflictsResolved) {
  print('${stats.conflicts - stats.conflictsResolved} conflicts unresolved');
}

// Push errors occurred, but sync completed
// This means some operations failed to push,
// but pull succeeded. Failed operations remain in the outbox.
if (stats.errors > 0) {
  print('${stats.errors} operations failed to push');
}
```

A situation where `errors > 0` with a successful `sync()` completion means that individual operations
from the outbox received a `PushError` from the server, but the push/pull cycle continued.
Failed operations remain in the outbox (if `skipConflictingOps = false`) and will be
retried during the next sync.

---

## Event lifecycle

### Normal sync (no conflicts)

```
SyncStarted(push)
  OperationPushedEvent (for each successful operation)
  SyncProgress(push, ...)
SyncStarted(pull)
  CacheUpdateEvent (for each page)
  SyncProgress(pull, done, total)
SyncCompleted(took, at, stats)
```

### Sync with conflict (autoPreserve strategy)

```
SyncStarted(push)
  ConflictDetectedEvent(conflict, autoPreserve)
  DataMergedEvent(kind, entityId, localFields, serverFields, mergedData)
  ConflictResolvedEvent(conflict, AcceptMerged, resultData)
SyncStarted(pull)
  CacheUpdateEvent(...)
  SyncProgress(pull, ...)
SyncCompleted(took, at, stats)
```

### Sync with error

```
SyncStarted(push)
  OperationFailedEvent(opId, kind, entityId, error, willRetry)
SyncStarted(pull)
  ...
SyncErrorEvent(phase, error, stackTrace)
```

If the error occurred during pull, the `SyncCompleted` event is **not emitted**.
Instead, a `SyncErrorEvent` is emitted, and then the exception is rethrown to the caller.

### Full resync

```
FullResyncStarted(reason)
SyncStarted(push)
  ...
SyncStarted(pull)
  CacheUpdateEvent(...)
  SyncProgress(pull, ...)
SyncCompleted(took, at, stats)
```

---

## Subscribing to events

### Basic subscription

```dart
final engine = SyncEngine(
  db: database,
  transport: transport,
  tables: tables,
);

engine.events.listen((event) {
  switch (event) {
    case SyncStarted(:final phase):
      print('Sync started: $phase');
    case SyncProgress(:final phase, :final done, :final total):
      print('Progress $phase: $done/$total');
    case SyncCompleted(:final took, :final stats):
      print('Completed in ${took.inMilliseconds}ms');
      if (stats != null) {
        print('Pushed: ${stats.pushed}, pulled: ${stats.pulled}');
      }
    case SyncErrorEvent(:final phase, :final error):
      print('Error in phase $phase: $error');
    case ConflictDetectedEvent(:final conflict, :final strategy):
      print('Conflict: ${conflict.kind}/${conflict.entityId}, strategy: $strategy');
    case ConflictResolvedEvent(:final conflict, :final resolution):
      print('Conflict resolved: ${conflict.entityId} -> ${resolution.runtimeType}');
    case ConflictUnresolvedEvent(:final conflict, :final reason):
      print('Conflict unresolved: ${conflict.entityId}: $reason');
    case DataMergedEvent(:final kind, :final entityId, :final localFields, :final serverFields):
      print('Merge $kind/$entityId: local=${localFields.length}, server=${serverFields.length}');
    case CacheUpdateEvent(:final kind, :final upserts, :final deletes):
      print('Cache $kind: +$upserts, -$deletes');
    case OperationPushedEvent(:final kind, :final entityId, :final operationType):
      print('Pushed: $operationType $kind/$entityId');
    case OperationFailedEvent(:final kind, :final entityId, :final error, :final willRetry):
      print('Error: $kind/$entityId: $error (retry: $willRetry)');
    case FullResyncStarted(:final reason):
      print('Full resync: $reason');
  }
});
```

### Filtering specific event types

```dart
// Errors only
engine.events
    .where((e) => e is SyncErrorEvent || e is OperationFailedEvent)
    .listen((event) {
  // ...
});

// Conflicts only
engine.events
    .whereType<ConflictDetectedEvent>()
    .listen((event) {
  print('Conflict: ${event.conflict.kind}/${event.conflict.entityId}');
});

// Completions only
engine.events
    .whereType<SyncCompleted>()
    .listen((event) {
  print('Sync completed in ${event.took.inMilliseconds}ms');
});
```

---

## UI integration

### StreamBuilder

```dart
class SyncStatusWidget extends StatelessWidget {
  const SyncStatusWidget({super.key, required this.engine});
  final SyncEngine engine;

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<SyncEvent>(
      stream: engine.events,
      builder: (context, snapshot) {
        final event = snapshot.data;

        return switch (event) {
          null => const Text('Waiting for sync'),
          SyncStarted(:final phase) =>
            Text('Syncing: ${phase == SyncPhase.push ? "pushing" : "pulling"}...'),
          SyncProgress(:final phase, :final done, :final total) =>
            LinearProgressIndicator(value: total > 0 ? done / total : null),
          SyncCompleted(:final stats) =>
            Text('Done: ${stats?.pushed ?? 0} pushed, ${stats?.pulled ?? 0} pulled'),
          SyncErrorEvent(:final error) =>
            Text('Error: $error', style: const TextStyle(color: Colors.red)),
          _ => const SizedBox.shrink(),
        };
      },
    );
  }
}
```

### ChangeNotifier

```dart
class SyncStatusNotifier extends ChangeNotifier {
  SyncStatusNotifier(this._engine) {
    _subscription = _engine.events.listen(_handleEvent);
  }

  final SyncEngine _engine;
  late final StreamSubscription<SyncEvent> _subscription;

  bool isSyncing = false;
  double progress = 0;
  String? lastError;
  SyncStats? lastStats;

  void _handleEvent(SyncEvent event) {
    switch (event) {
      case SyncStarted():
        isSyncing = true;
        progress = 0;
        lastError = null;
      case SyncProgress(:final done, :final total):
        progress = total > 0 ? done / total : 0;
      case SyncCompleted(:final stats):
        isSyncing = false;
        progress = 1.0;
        lastStats = stats;
      case SyncErrorEvent(:final error):
        isSyncing = false;
        lastError = error.toString();
      default:
        return; // Don't notify for other events
    }
    notifyListeners();
  }

  @override
  void dispose() {
    _subscription.cancel();
    super.dispose();
  }
}
```

---

## Logging

### Full logging setup

```dart
import 'dart:developer' as developer;

void setupSyncLogging(SyncEngine engine) {
  engine.events.listen((event) {
    switch (event) {
      // Informational events
      case SyncStarted(:final phase):
        developer.log('Sync started: $phase', name: 'sync');
      case SyncProgress(:final phase, :final done, :final total):
        developer.log('Sync progress: $phase $done/$total', name: 'sync');
      case SyncCompleted(:final took, :final stats):
        developer.log(
          'Sync completed in ${took.inMilliseconds}ms. $stats',
          name: 'sync',
        );
      case FullResyncStarted(:final reason):
        developer.log('Full resync started: $reason', name: 'sync');

      // Operations
      case OperationPushedEvent(:final operationType, :final kind, :final entityId):
        developer.log('Pushed: $operationType $kind/$entityId', name: 'sync.push');
      case CacheUpdateEvent(:final kind, :final upserts, :final deletes):
        developer.log('Cache update: $kind +$upserts -$deletes', name: 'sync.pull');

      // Conflicts
      case ConflictDetectedEvent(:final conflict, :final strategy):
        developer.log(
          'Conflict detected: ${conflict.kind}/${conflict.entityId}, strategy: $strategy',
          name: 'sync.conflict',
        );
      case ConflictResolvedEvent(:final conflict, :final resolution):
        developer.log(
          'Conflict resolved: ${conflict.kind}/${conflict.entityId} -> ${resolution.runtimeType}',
          name: 'sync.conflict',
        );
      case ConflictUnresolvedEvent(:final conflict, :final reason):
        developer.log(
          'Conflict unresolved: ${conflict.kind}/${conflict.entityId}: $reason',
          name: 'sync.conflict',
          level: 900, // WARNING
        );
      case DataMergedEvent(:final kind, :final entityId, :final localFields, :final serverFields):
        developer.log(
          'Data merged: $kind/$entityId (local: ${localFields.length}, server: ${serverFields.length})',
          name: 'sync.conflict',
        );

      // Errors
      case SyncErrorEvent(:final phase, :final error, :final stackTrace):
        developer.log(
          'Sync error during $phase: $error',
          name: 'sync.error',
          level: 1000, // SEVERE
          error: error,
          stackTrace: stackTrace,
        );
      case OperationFailedEvent(:final kind, :final entityId, :final error, :final willRetry):
        developer.log(
          'Operation failed: $kind/$entityId: $error (willRetry: $willRetry)',
          name: 'sync.error',
          level: 900, // WARNING
        );
    }
  });
}
```

### Production logging (errors and warnings only)

```dart
void setupProductionLogging(SyncEngine engine) {
  engine.events.listen((event) {
    switch (event) {
      case SyncErrorEvent(:final phase, :final error, :final stackTrace):
        // Send to crash reporting
        reportError(error, stackTrace);
      case OperationFailedEvent(:final kind, :final entityId, :final error):
        reportWarning('Push failed: $kind/$entityId: $error');
      case ConflictUnresolvedEvent(:final conflict, :final reason):
        reportWarning('Unresolved conflict: ${conflict.kind}/${conflict.entityId}: $reason');
      case SyncCompleted(:final stats):
        if (stats != null && stats.errors > 0) {
          reportWarning('Sync completed with ${stats.errors} errors');
        }
      default:
        break;
    }
  });
}
```

---

## SyncException — base sealed class

```dart
sealed class SyncException implements Exception {
  const SyncException(this.message, [this.cause, this.stackTrace]);

  final String message;
  final Object? cause;
  final StackTrace? stackTrace;
}
```

All sync exceptions inherit from `SyncException`. It is a `sealed class`,
which enables exhaustive pattern matching.

**Common fields (inherited by all subtypes):**

| Field        | Type          | Description                        |
|--------------|---------------|------------------------------------|
| `message`    | `String`      | Error description                  |
| `cause`      | `Object?`     | Original cause of the error        |
| `stackTrace` | `StackTrace?` | Stack trace of the original error  |

### Full list of subtypes

| Class                        | Purpose                                       |
|------------------------------|-----------------------------------------------|
| `NetworkException`           | Network errors (server unreachable, timeout)  |
| `TransportException`         | Transport layer errors (HTTP)                 |
| `DatabaseException`          | Database errors                               |
| `ConflictException`          | Unresolved data conflict                      |
| `SyncOperationException`     | General sync operation error                  |
| `MaxRetriesExceededException`| Maximum retry count exceeded                  |
| `ParseException`             | Data parsing error                            |

---

## Detailed description of each exception

### NetworkException

Network errors: server unreachable, timeout, no internet connection.

```dart
class NetworkException extends SyncException {
  const NetworkException(super.message, [super.cause, super.stackTrace]);

  factory NetworkException.fromError(Object error, [StackTrace? stackTrace]);
}
```

**Constructors:**

| Constructor                    | Description                                  |
|--------------------------------|----------------------------------------------|
| `NetworkException(message)`    | Base constructor                             |
| `NetworkException.fromError(error)` | Create from original network error      |

**Caused by:** Connection timeout, DNS resolution failure, no network, server not responding.

**Recovery:** Retry with exponential backoff. This is a transient error.

---

### TransportException

Transport layer errors: unexpected HTTP response from the server.

```dart
class TransportException extends SyncException {
  const TransportException(
    String message, {
    this.statusCode,
    this.responseBody,
    Object? cause,
    StackTrace? stackTrace,
  });

  final int? statusCode;
  final String? responseBody;

  factory TransportException.httpError(int statusCode, [String? body]);
}
```

**Additional fields:**

| Field          | Type      | Description          |
|----------------|-----------|----------------------|
| `statusCode`   | `int?`    | HTTP status code     |
| `responseBody` | `String?` | Server response body |

**Constructors:**

| Constructor                          | Description                        |
|--------------------------------------|------------------------------------|
| `TransportException(message, ...)`   | Full constructor                   |
| `TransportException.httpError(code)` | Create from HTTP status code       |

**Caused by:** HTTP 4xx/5xx responses, incorrect server response format.

**Recovery:**
- 5xx (server errors) — retry with backoff.
- 401/403 — refresh the auth token.
- 400/422 — data error, retry will not help.
- 429 — too many requests, retry later.

---

### DatabaseException

Errors when working with the local database (Drift).

```dart
class DatabaseException extends SyncException {
  const DatabaseException(super.message, [super.cause, super.stackTrace]);

  factory DatabaseException.fromError(Object error, [StackTrace? stackTrace]);
}
```

**Constructors:**

| Constructor                      | Description                               |
|----------------------------------|-------------------------------------------|
| `DatabaseException(message)`     | Base constructor                          |
| `DatabaseException.fromError(e)` | Create from original DB error             |

**Caused by:** Constraint errors, DB corruption, insufficient disk space, migration errors.

**Recovery:** Depends on the cause. Usually not transient. May require
data cleanup or database reinitialization.

---

### ConflictException

Unresolved data conflict between the client and server.

```dart
class ConflictException extends SyncException {
  const ConflictException(
    String message, {
    required this.kind,
    required this.entityId,
    this.localData,
    this.serverData,
    Object? cause,
    StackTrace? stackTrace,
  });

  final String kind;
  final String entityId;
  final Map<String, Object?>? localData;
  final Map<String, Object?>? serverData;
}
```

**Additional fields:**

| Field        | Type                    | Description         |
|--------------|-------------------------|---------------------|
| `kind`       | `String`                | Entity type         |
| `entityId`   | `String`                | Entity ID           |
| `localData`  | `Map<String, Object?>?` | Local data          |
| `serverData` | `Map<String, Object?>?` | Server data         |

**Caused by:** A conflict that could not be resolved automatically
by any strategy.

**Recovery:** Manual conflict resolution via UI, or switching
the strategy to `serverWins` / `clientWins`.

---

### SyncOperationException

General sync operation error that wraps unexpected errors.

```dart
class SyncOperationException extends SyncException {
  const SyncOperationException(
    String message, {
    this.phase,
    this.opId,
    Object? cause,
    StackTrace? stackTrace,
  });

  final String? phase;
  final String? opId;
}
```

**Additional fields:**

| Field   | Type      | Description                                    |
|---------|-----------|------------------------------------------------|
| `phase` | `String?` | Sync phase (`"push"`, `"pull"`, `"sync"`, `"fullResync"`) |
| `opId`  | `String?` | Operation ID (if applicable)                   |

**Caused by:** Wraps any unhandled exceptions inside
`_doSync()`, `_doFullResync()`, `pushAll()`, `pullKind()`.

**Recovery:** Depends on the nested error (`cause`). Check `cause`
to determine the actual reason.

---

### MaxRetriesExceededException

Maximum push retry count exceeded.

```dart
class MaxRetriesExceededException extends SyncException {
  const MaxRetriesExceededException(
    String message, {
    required this.attempts,
    required this.maxRetries,
    Object? cause,
    StackTrace? stackTrace,
  });

  final int attempts;
  final int maxRetries;
}
```

**Additional fields:**

| Field        | Type  | Description                       |
|--------------|-------|-----------------------------------|
| `attempts`   | `int` | Number of attempts made           |
| `maxRetries` | `int` | Maximum number of attempts        |

**Caused by:** Thrown in `PushService._pushBatch()` when
`attempt >= config.maxPushRetries` (default 5). Each attempt
uses exponential backoff from `backoffMin` to `backoffMax`.

**Recovery:** This means the server has been unavailable for an extended period.
It is recommended to wait and retry sync later. Operations remain
in the outbox.

---

### ParseException

Error parsing data received from the server.

```dart
class ParseException extends SyncException {
  const ParseException(super.message, [super.cause, super.stackTrace]);

  factory ParseException.fromError(Object error, [StackTrace? stackTrace]);
}
```

**Constructors:**

| Constructor                   | Description                          |
|-------------------------------|--------------------------------------|
| `ParseException(message)`     | Base constructor                     |
| `ParseException.fromError(e)` | Create from parsing error            |

**Caused by:** Missing required `updatedAt` field in server response,
invalid JSON, invalid data types.

**Recovery:** Not transient. Indicates a server API issue
or version incompatibility. Check the data format.

---

## Full pattern matching for exceptions

```dart
try {
  await engine.sync();
} on SyncException catch (e) {
  switch (e) {
    case NetworkException():
      // No network — show offline indicator, retry later
      showOfflineIndicator();
      scheduleRetry(delay: const Duration(minutes: 1));

    case TransportException(:final statusCode):
      if (statusCode != null && statusCode >= 500) {
        // Server error — retry later
        scheduleRetry(delay: const Duration(minutes: 5));
      } else if (statusCode == 401 || statusCode == 403) {
        // Auth issues — refresh token
        await refreshAuthToken();
        await engine.sync();
      } else {
        // Client error — log, don't retry
        reportError(e);
      }

    case DatabaseException():
      // Local DB error — critical situation
      reportCriticalError(e);

    case ConflictException(:final kind, :final entityId):
      // Unresolved conflict
      showConflictResolutionUI(kind: kind, entityId: entityId);

    case SyncOperationException(:final phase, :final cause):
      // General error — analyze cause
      reportError(e);
      if (cause is NetworkException) {
        scheduleRetry(delay: const Duration(minutes: 1));
      }

    case MaxRetriesExceededException(:final attempts, :final maxRetries):
      // All attempts exhausted
      showError('Failed to sync after $attempts of $maxRetries attempts');
      scheduleRetry(delay: const Duration(minutes: 10));

    case ParseException():
      // Problem with server data
      reportError(e);
      // Consider calling fullResync after the API is fixed
  }
}
```

---

## Retry and recovery

### Which exceptions support retries

| Exception                     | Retryable | Comment                                      |
|-------------------------------|-----------|----------------------------------------------|
| `NetworkException`            | Yes       | Transient, always worth retrying             |
| `TransportException` (5xx)    | Yes       | Server errors are usually temporary          |
| `TransportException` (4xx)    | No        | Client-side error                            |
| `TransportException` (401/403)| Partially | Retry after refreshing the token             |
| `TransportException` (429)    | Yes       | Rate limiting, retry with delay              |
| `DatabaseException`           | No        | Usually a permanent error                    |
| `ConflictException`           | No        | Requires manual resolution                   |
| `SyncOperationException`      | Depends   | Check `cause`                                |
| `MaxRetriesExceededException` | Yes       | Retry later with a longer delay              |
| `ParseException`              | No        | Data error, retry will not help              |

### How push backoff works

Exponential backoff is configured via `SyncConfig`:

```dart
SyncConfig(
  backoffMin: Duration(seconds: 1),     // Initial delay
  backoffMax: Duration(minutes: 2),     // Maximum delay
  backoffMultiplier: 2.0,              // Multiplier
  maxPushRetries: 5,                   // Maximum number of attempts
)
```

Delay sequence with `maxPushRetries: 5`:

| Attempt | Delay (with multiplier 2.0) |
|---------|-----------------------------|
| 1       | None (first attempt)        |
| 2       | 1 second                    |
| 3       | 2 seconds                   |
| 4       | 4 seconds                   |
| 5       | 8 seconds                   |

Formula: `delay = min(backoffMin * pow(backoffMultiplier, attempt - 1), backoffMax)`

After all attempts are exhausted, `MaxRetriesExceededException` is thrown.

### Conflict backoff

For conflict resolution retries (with `clientWins` and `merge`/`autoPreserve`),
separate parameters are used:

```dart
SyncConfig(
  maxConflictRetries: 3,                        // Maximum number of attempts
  conflictRetryDelay: Duration(milliseconds: 500), // Fixed delay
)
```

If the conflict is not resolved after `maxConflictRetries` attempts:
- If `skipConflictingOps = true` — the operation is removed from the outbox.
- If `skipConflictingOps = false` — the operation remains in the outbox for the next cycle.

### When to give up on retries

```dart
try {
  await engine.sync();
} on ParseException {
  // Don't retry — server data is invalid
  // Wait for a server-side fix
} on DatabaseException {
  // Don't retry — local issue
  // Database reinitialization may be needed
} on ConflictException {
  // Don't retry automatically — user decision required
} on TransportException catch (e) {
  if (e.statusCode != null && e.statusCode! >= 400 && e.statusCode! < 500) {
    if (e.statusCode != 429) {
      // 4xx except 429 — don't retry
      return;
    }
  }
  // For others — retry
  scheduleRetry();
} on NetworkException {
  // Retry later
  scheduleRetry();
} on MaxRetriesExceededException {
  // Retry much later
  scheduleRetry(delay: const Duration(minutes: 30));
}
```

---

## Full example: error handling and monitoring

```dart
import 'dart:async';
import 'dart:developer' as developer;

class SyncMonitor {
  SyncMonitor(this._engine) {
    _subscription = _engine.events.listen(_handleEvent);
  }

  final SyncEngine _engine;
  late final StreamSubscription<SyncEvent> _subscription;

  int _consecutiveFailures = 0;
  static const _maxConsecutiveFailures = 5;

  void _handleEvent(SyncEvent event) {
    switch (event) {
      case SyncCompleted(:final stats):
        _consecutiveFailures = 0;
        _logInfo('Sync OK: $stats');
        if (stats != null && stats.errors > 0) {
          _logWarning('Sync completed with ${stats.errors} push errors');
        }

      case SyncErrorEvent(:final phase, :final error, :final stackTrace):
        _consecutiveFailures++;
        _logError('Sync error ($phase): $error', stackTrace);
        if (_consecutiveFailures >= _maxConsecutiveFailures) {
          _logError('$_consecutiveFailures consecutive failures, stopping auto-sync');
          _engine.stopAuto();
        }

      case ConflictDetectedEvent(:final conflict, :final strategy):
        _logInfo('Conflict: ${conflict.kind}/${conflict.entityId}, strategy: $strategy');

      case ConflictUnresolvedEvent(:final conflict, :final reason):
        _logWarning('Unresolved conflict: ${conflict.kind}/${conflict.entityId}: $reason');

      case OperationFailedEvent(:final kind, :final entityId, :final error):
        _logWarning('Op failed: $kind/$entityId: $error');

      default:
        break;
    }
  }

  Future<SyncStats> syncWithRetry({int maxRetries = 3}) async {
    for (var i = 0; i < maxRetries; i++) {
      try {
        return await _engine.sync();
      } on NetworkException {
        if (i == maxRetries - 1) rethrow;
        await Future<void>.delayed(Duration(seconds: (i + 1) * 5));
      } on MaxRetriesExceededException {
        if (i == maxRetries - 1) rethrow;
        await Future<void>.delayed(Duration(seconds: (i + 1) * 10));
      } on TransportException catch (e) {
        if (e.statusCode != null && e.statusCode! < 500 && e.statusCode != 429) {
          rethrow; // Don't retry client errors
        }
        if (i == maxRetries - 1) rethrow;
        await Future<void>.delayed(Duration(seconds: (i + 1) * 5));
      }
    }
    // unreachable
    throw StateError('Unreachable');
  }

  void _logInfo(String msg) =>
      developer.log(msg, name: 'sync.monitor');

  void _logWarning(String msg) =>
      developer.log(msg, name: 'sync.monitor', level: 900);

  void _logError(String msg, [StackTrace? st]) =>
      developer.log(msg, name: 'sync.monitor', level: 1000, stackTrace: st);

  void dispose() => _subscription.cancel();
}
```

---

## Helper types

### Conflict

Full data conflict information. Used in `ConflictDetectedEvent`,
`ConflictResolvedEvent`, `ConflictUnresolvedEvent` events.

```dart
class Conflict {
  const Conflict({
    required this.kind,
    required this.entityId,
    required this.opId,
    required this.localData,
    required this.serverData,
    required this.localTimestamp,
    required this.serverTimestamp,
    this.serverVersion,
    this.changedFields,
  });

  final String kind;
  final String entityId;
  final String opId;
  final Map<String, Object?> localData;
  final Map<String, Object?> serverData;
  final DateTime localTimestamp;
  final DateTime serverTimestamp;
  final String? serverVersion;
  final Set<String>? changedFields;
}
```

| Field             | Type                    | Description                                    |
|-------------------|-------------------------|------------------------------------------------|
| `kind`            | `String`                | Entity type                                    |
| `entityId`        | `String`                | Entity ID                                      |
| `opId`            | `String`                | Operation ID from the outbox                   |
| `localData`       | `Map<String, Object?>`  | Client data                                    |
| `serverData`      | `Map<String, Object?>`  | Server data                                    |
| `localTimestamp`   | `DateTime`              | Local modification time                        |
| `serverTimestamp`  | `DateTime`              | Server modification time                       |
| `serverVersion`   | `String?`               | Server version (ETag, version number)          |
| `changedFields`   | `Set<String>?`          | Fields changed by the client (for autoPreserve)|

### ConflictResolution (sealed class)

Conflict resolution result. Used in `ConflictResolvedEvent.resolution`.

```dart
sealed class ConflictResolution {}
```

| Subtype            | Description                                  |
|--------------------|----------------------------------------------|
| `AcceptServer`     | Accept the server version                    |
| `AcceptClient`     | Accept the client version (force push)       |
| `AcceptMerged`     | Use merged data                              |
| `DeferResolution`  | Defer resolution (keep in outbox)            |
| `DiscardOperation` | Discard the operation (remove from outbox)   |

### ConflictStrategy enum

Conflict resolution strategy. Used in `ConflictDetectedEvent.strategy`.

```dart
enum ConflictStrategy {
  serverWins,
  clientWins,
  lastWriteWins,
  merge,
  manual,
  autoPreserve,
}
```

| Value          | Description                                           |
|----------------|-------------------------------------------------------|
| `serverWins`   | Server version always wins                            |
| `clientWins`   | Client version always wins (force push)               |
| `lastWriteWins`| Version with the later timestamp wins                 |
| `merge`        | Data merge via `mergeFunction`                        |
| `manual`       | Manual resolution via `conflictResolver` callback     |
| `autoPreserve` | Automatic smart merge without data loss (default)     |
